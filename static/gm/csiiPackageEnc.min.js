var tempSM4Key = "";

function packageEncrypt(t, e) {
    if (t == "") {
        return ""
    }
    if (tempSM4Key == "") {
        tempSM4Key = RndNum(32)
    }
    var r = hex2b64(SM4.encode({
        input: t,
        key: tempSM4Key
    }));
    var n = hex2b64(SM2Encrypt(tempSM4Key, e));
    var i = hex2b64(SM3Encrypt(t));
    var s = n + "|" + r + "|" + i;
    return s
}

function packageDecrypt(t) {
    if (t == "") {
        return ""
    }
    if (tempSM4Key == "") {
        //console.log("key is invalid.");
        return ""
    }
    t = b64tohex(t);
    var e = SM4.decode({
        input: t,
        key: tempSM4Key
    });
    return e
}

function sm2StandardEncrypt(t, e) {
    if (t == "") {
        return ""
    }
    var r = RndNum(32);
    var n = SM2Encrypt(r, e);
    var i = SM4.encode({
        input: t,
        key: r
    });
    var s = "3030303030313234010200000168000000a40000" + n + "303030303030" + stringtoHex(i.length / 2 + "") + i;
    return hex2b64(s)
}

function SM3Encrypt(t) {
    var e = new SM3Digest;
    e.BlockUpdate(stringToByte(t), 0, stringToByte(t).length);
    var r = new Array(32);
    e.DoFinal(r, 0);
    return bin2hex(r).toUpperCase()
}

function stringToByte(t) {
    var e = new Array;
    var r, n;
    r = t.length;
    for (var i = 0; i < r; i++) {
        n = t.charCodeAt(i);
        if (n >= 65536 && n <= 1114111) {
            e.push(n >> 18 & 7 | 240);
            e.push(n >> 12 & 63 | 128);
            e.push(n >> 6 & 63 | 128);
            e.push(n & 63 | 128)
        } else if (n >= 2048 && n <= 65535) {
            e.push(n >> 12 & 15 | 224);
            e.push(n >> 6 & 63 | 128);
            e.push(n & 63 | 128)
        } else if (n >= 128 && n <= 2047) {
            e.push(n >> 6 & 31 | 192);
            e.push(n & 63 | 128)
        } else {
            e.push(n & 255)
        }
    }
    return e
}

function RndNum(t) {
    var e = "";
    for (var r = 0; r < t; r++) {
        e += Math.floor(Math.random() * 10)
    }
    return e
}

function stringtoHex(t) {
    var e = "";
    for (var r = 0; r < t.length; r++) {
        if (e == "") {
            e = t.charCodeAt(r).toString(16)
        } else {
            e += t.charCodeAt(r).toString(16)
        }
    }
    return e
}

function SM2Encrypt(t, e) {
    var r = new SM2Cipher(1);
    t = r.str2Bytes(t.toString());
    var n = r.Encrypt(e, t);
    return n.toUpperCase()
}

function SM2Cipher(t) {
    this.ct = 1;
    this.p2 = null;
    this.sm3keybase = null;
    this.sm3c3 = null;
    this.key = new Array(32);
    this.keyOff = 0;
    if (typeof t != "undefined") {
        this.cipherMode = t
    } else {
        this.cipherMode = SM2CipherMode.C1C3C2
    }
}
SM2Cipher.prototype = {
    Reset: function () {
        this.sm3keybase = new SM3Digest;
        this.sm3c3 = new SM3Digest;
        var t = this.byteConvert32Bytes(this.p2.getX().toBigInteger());
        var e = this.byteConvert32Bytes(this.p2.getY().toBigInteger());
        this.sm3keybase.BlockUpdate(t, 0, t.length);
        this.sm3c3.BlockUpdate(t, 0, t.length);
        this.sm3keybase.BlockUpdate(e, 0, e.length);
        this.ct = 1;
        this.NextKey()
    },
    NextKey: function () {
        var t = new SM3Digest(this.sm3keybase);
        t.Update(this.ct >> 24 & 255);
        t.Update(this.ct >> 16 & 255);
        t.Update(this.ct >> 8 & 255);
        t.Update(this.ct & 255);
        t.DoFinal(this.key, 0);
        this.keyOff = 0;
        this.ct++
    },
    InitEncipher: function (t) {
        var e = null;
        var r = null;
        var n = new KJUR.crypto.ECDSA({
            curve: "sm2"
        });
        var i = n.generateKeyPairHex();
        e = new BigInteger(i.ecprvhex, 16);
        var s = i.ecpubhex;
        r = ECPointFp.decodeFromHex(n.ecparams["curve"], s);
        this.p2 = t.multiply(e);
        this.Reset();
        return r
    },
    EncryptBlock: function (t) {
        this.sm3c3.BlockUpdate(t, 0, t.length);
        for (var e = 0; e < t.length; e++) {
            if (this.keyOff == this.key.length) {
                this.NextKey()
            }
            t[e] ^= this.key[this.keyOff++]
        }
    },
    InitDecipher: function (t, e) {
        this.p2 = e.multiply(t);
        this.Reset()
    },
    DecryptBlock: function (t) {
        for (var e = 0; e < t.length; e++) {
            if (this.keyOff == this.key.length) {
                this.NextKey()
            }
            t[e] ^= this.key[this.keyOff++]
        }
        this.sm3c3.BlockUpdate(t, 0, t.length)
    },
    Dofinal: function (t) {
        var e = this.byteConvert32Bytes(this.p2.getY().toBigInteger());
        this.sm3c3.BlockUpdate(e, 0, e.length);
        this.sm3c3.DoFinal(t, 0);
        this.Reset()
    },
    Encrypt: function (t, e) {
        var r = new Array(e.length);
        Array.Copy(e, 0, r, 0, e.length);
        var n = this.InitEncipher(this.CreatePoint("04" + t));
        this.EncryptBlock(r);
        var i = new Array(32);
        this.Dofinal(i);
        var s = this.bin2hex(n.getEncoded(false)) + this.bin2hex(r) + this.bin2hex(i);
        if (this.cipherMode == SM2CipherMode.C1C3C2) {
            s = this.bin2hex(n.getEncoded(false)) + this.bin2hex(i) + this.bin2hex(r)
        }
        return s
    },
    GetWords: function (t) {
        var e = [];
        var r = t.length;
        for (var n = 0; n < r; n += 2) {
            e[e.length] = parseInt(t.substr(n, 2), 16)
        }
        return e
    },
    byteConvert32Bytes: function (t) {
        var e = [];
        if (t == null) {
            return e
        }
        if (t.toByteArray().length == 33) {
            e = new Array(32);
            Array.Copy(t.toByteArray(), 1, e, 0, 32)
        } else if (t.toByteArray().length == 32) {
            e = t.toByteArray()
        } else {
            e = new Array(32);
            for (var r = 0; r < 32 - t.toByteArray().length; r++) {
                e[r] = 0
            }
            Array.Copy(t.toByteArray(), 0, e, 32 - t.toByteArray().length, t.toByteArray().length)
        }
        for (var r = 0; r < 32; r++) {
            e[r] &= 255
        }
        return e
    },
    bin2hex: function (t) {
        var e = "0123456789abcdef";
        var r = "";
        for (i = 0; i < t.length; i++) {
            var n = t[i] & 255;
            r += e.charAt(n >>> 4);
            r += e.charAt(n & 15)
        }
        return r
    },
    str2Bytes: function (t) {
        var e = 0;
        var r = t.length;
        if (r % 2 != 0) {
            return null
        }
        var n = new Array;
        for (; e < r; e += 2) {
            var i = parseInt(t.charAt(e), 16);
            var s = parseInt(t.charAt(e + 1), 16);
            var a = i << 4 | s;
            n.push(a)
        }
        return n
    },
    GetHex: function (t) {
        var e = [];
        var r = 0;
        for (var n = 0; n < t.length * 2; n += 2) {
            e[n >>> 3] |= parseInt(t[r]) << 24 - n % 8 * 4;
            r++
        }
        var i = new CryptoJS.lib.WordArray.init(e, t.length);
        return i
    },
    Decrypt: function (t, e) {
        var r = "04" + e;
        var n = r.substr(0, 130);
        var i = r.substr(n.length, r.length - n.length - 64);
        var s = r.substr(r.length - 64);
        if (this.cipherMode == SM2CipherMode.C1C3C2) {
            s = r.substr(n.length, 64);
            i = r.substr(n.length + 64)
        }
        var a = this.str2Bytes(i);
        var h = this.CreatePoint(n);
        this.InitDecipher(t, h);
        this.DecryptBlock(a);
        var o = new Array(32);
        this.Dofinal(o);
        var f = this.bin2hex(o).toString() == s;
        if (f) {
            var u = CryptoJS.enc.Hex.parse(this.bin2hex(a));
            var c = CryptoJS.enc.Utf8.stringify(u);
            return c
        } else {
            return ""
        }
    },
    CreatePoint: function (t) {
        var e = new KJUR.crypto.ECDSA({
            curve: "sm2"
        });
        var r = e.ecparams["curve"];
        var n = ECPointFp.decodeFromHex(e.ecparams["curve"], t);
        return n
    }
};
window.SM2CipherMode = {
    C1C2C3: "0",
    C1C3C2: "1"
};
(function () {
    var t = CryptoJS;
    var e = t.lib;
    var r = e.WordArray;
    var n = e.Hasher;
    var i = t.algo;
    var c = [];
    var s = i.SM3 = n.extend({
        _doReset: function () {
            this._hash = new r.init([1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214])
        },
        _doProcessBlock: function (t, e) {
            var r = this._hash.words;
            var n = r[0];
            var i = r[1];
            var s = r[2];
            var a = r[3];
            var h = r[4];
            for (var o = 0; o < 80; o++) {
                if (o < 16) {
                    c[o] = t[e + o] | 0
                } else {
                    var f = c[o - 3] ^ c[o - 8] ^ c[o - 14] ^ c[o - 16];
                    c[o] = f << 1 | f >>> 31
                }
                var u = (n << 5 | n >>> 27) + h + c[o];
                if (o < 20) {
                    u += (i & s | ~i & a) + 1518500249
                } else if (o < 40) {
                    u += (i ^ s ^ a) + 1859775393
                } else if (o < 60) {
                    u += (i & s | i & a | s & a) - 1894007588
                } else {
                    u += (i ^ s ^ a) - 899497514
                }
                h = a;
                a = s;
                s = i << 30 | i >>> 2;
                i = n;
                n = u
            }
            r[0] = r[0] + n | 0;
            r[1] = r[1] + i | 0;
            r[2] = r[2] + s | 0;
            r[3] = r[3] + a | 0;
            r[4] = r[4] + h | 0
        },
        _doFinalize: function () {
            var t = this._data;
            var e = t.words;
            var r = this._nDataBytes * 8;
            var n = t.sigBytes * 8;
            e[n >>> 5] |= 128 << 24 - n % 32;
            e[(n + 64 >>> 9 << 4) + 14] = Math.floor(r / 4294967296);
            e[(n + 64 >>> 9 << 4) + 15] = r;
            t.sigBytes = e.length * 4;
            this._process();
            return this._hash
        },
        clone: function () {
            var t = n.clone.call(this);
            t._hash = this._hash.clone();
            return t
        }
    });
    t.SM3 = n._createHelper(s);
    t.HmacSM3 = n._createHmacHelper(s)
})();

function SM3Digest() {
    this.BYTE_LENGTH = 64;
    this.xBuf = new Array;
    this.xBufOff = 0;
    this.byteCount = 0;
    this.DIGEST_LENGTH = 32;
    this.v0 = [1937774191, 1226093241, 388252375, 3666478592, 2842636476, 372324522, 3817729613, 2969243214];
    this.v0 = [1937774191, 1226093241, 388252375, -628488704, -1452330820, 372324522, -477237683, -1325724082];
    this.v = new Array(8);
    this.v_ = new Array(8);
    this.X0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.X = new Array(68);
    this.xOff = 0;
    this.T_00_15 = 2043430169;
    this.T_16_63 = 2055708042;
    if (arguments.length > 0) {
        this.InitDigest(arguments[0])
    } else {
        this.Init()
    }
}
SM3Digest.prototype = {
    Init: function () {
        this.xBuf = new Array(4);
        this.Reset()
    },
    InitDigest: function (t) {
        this.xBuf = new Array(t.xBuf.length);
        Array.Copy(t.xBuf, 0, this.xBuf, 0, t.xBuf.length);
        this.xBufOff = t.xBufOff;
        this.byteCount = t.byteCount;
        Array.Copy(t.X, 0, this.X, 0, t.X.length);
        this.xOff = t.xOff;
        Array.Copy(t.v, 0, this.v, 0, t.v.length)
    },
    GetDigestSize: function () {
        return this.DIGEST_LENGTH
    },
    Reset: function () {
        this.byteCount = 0;
        this.xBufOff = 0;
        Array.Clear(this.xBuf, 0, this.xBuf.length);
        Array.Copy(this.v0, 0, this.v, 0, this.v0.length);
        this.xOff = 0;
        Array.Copy(this.X0, 0, this.X, 0, this.X0.length)
    },
    GetByteLength: function () {
        return this.BYTE_LENGTH
    },
    ProcessBlock: function () {
        var t;
        var e = this.X;
        var r = new Array(64);
        for (t = 16; t < 68; t++) {
            e[t] = this.P1(e[t - 16] ^ e[t - 9] ^ this.ROTATE(e[t - 3], 15)) ^ this.ROTATE(e[t - 13], 7) ^ e[t - 6]
        }
        for (t = 0; t < 64; t++) {
            r[t] = e[t] ^ e[t + 4]
        }
        var n = this.v;
        var i = this.v_;
        Array.Copy(n, 0, i, 0, this.v0.length);
        var s, a, h, o, f;
        for (t = 0; t < 16; t++) {
            f = this.ROTATE(i[0], 12);
            s = Int32.parse(Int32.parse(f + i[4]) + this.ROTATE(this.T_00_15, t));
            s = this.ROTATE(s, 7);
            a = s ^ f;
            h = Int32.parse(Int32.parse(this.FF_00_15(i[0], i[1], i[2]) + i[3]) + a) + r[t];
            o = Int32.parse(Int32.parse(this.GG_00_15(i[4], i[5], i[6]) + i[7]) + s) + e[t];
            i[3] = i[2];
            i[2] = this.ROTATE(i[1], 9);
            i[1] = i[0];
            i[0] = h;
            i[7] = i[6];
            i[6] = this.ROTATE(i[5], 19);
            i[5] = i[4];
            i[4] = this.P0(o)
        }
        for (t = 16; t < 64; t++) {
            f = this.ROTATE(i[0], 12);
            s = Int32.parse(Int32.parse(f + i[4]) + this.ROTATE(this.T_16_63, t));
            s = this.ROTATE(s, 7);
            a = s ^ f;
            h = Int32.parse(Int32.parse(this.FF_16_63(i[0], i[1], i[2]) + i[3]) + a) + r[t];
            o = Int32.parse(Int32.parse(this.GG_16_63(i[4], i[5], i[6]) + i[7]) + s) + e[t];
            i[3] = i[2];
            i[2] = this.ROTATE(i[1], 9);
            i[1] = i[0];
            i[0] = h;
            i[7] = i[6];
            i[6] = this.ROTATE(i[5], 19);
            i[5] = i[4];
            i[4] = this.P0(o)
        }
        for (t = 0; t < 8; t++) {
            n[t] ^= Int32.parse(i[t])
        }
        this.xOff = 0;
        Array.Copy(this.X0, 0, this.X, 0, this.X0.length)
    },
    ProcessWord: function (t, e) {
        var r = t[e] << 24;
        r |= (t[++e] & 255) << 16;
        r |= (t[++e] & 255) << 8;
        r |= t[++e] & 255;
        this.X[this.xOff] = r;
        if (++this.xOff == 16) {
            this.ProcessBlock()
        }
    },
    ProcessLength: function (t) {
        if (this.xOff > 14) {
            this.ProcessBlock()
        }
        this.X[14] = this.URShiftLong(t, 32);
        this.X[15] = t & 4294967295
    },
    IntToBigEndian: function (t, e, r) {
        e[r] = Int32.parseByte(this.URShift(t, 24));
        e[++r] = Int32.parseByte(this.URShift(t, 16));
        e[++r] = Int32.parseByte(this.URShift(t, 8));
        e[++r] = Int32.parseByte(t)
    },
    DoFinal: function (t, e) {
        this.Finish();
        for (var r = 0; r < 8; r++) {
            this.IntToBigEndian(this.v[r], t, e + r * 4)
        }
        this.Reset();
        return this.DIGEST_LENGTH
    },
    Update: function (t) {
        this.xBuf[this.xBufOff++] = t;
        if (this.xBufOff == this.xBuf.length) {
            this.ProcessWord(this.xBuf, 0);
            this.xBufOff = 0
        }
        this.byteCount++
    },
    BlockUpdate: function (t, e, r) {
        while (this.xBufOff != 0 && r > 0) {
            this.Update(t[e]);
            e++;
            r--
        }
        while (r > this.xBuf.length) {
            this.ProcessWord(t, e);
            e += this.xBuf.length;
            r -= this.xBuf.length;
            this.byteCount += this.xBuf.length
        }
        while (r > 0) {
            this.Update(t[e]);
            e++;
            r--
        }
    },
    Finish: function () {
        var t = this.byteCount << 3;
        this.Update(128);
        while (this.xBufOff != 0) this.Update(0);
        this.ProcessLength(t);
        this.ProcessBlock()
    },
    ROTATE: function (t, e) {
        return t << e | this.URShift(t, 32 - e)
    },
    P0: function (t) {
        return t ^ this.ROTATE(t, 9) ^ this.ROTATE(t, 17)
    },
    P1: function (t) {
        return t ^ this.ROTATE(t, 15) ^ this.ROTATE(t, 23)
    },
    FF_00_15: function (t, e, r) {
        return t ^ e ^ r
    },
    FF_16_63: function (t, e, r) {
        return t & e | t & r | e & r
    },
    GG_00_15: function (t, e, r) {
        return t ^ e ^ r
    },
    GG_16_63: function (t, e, r) {
        return t & e | ~t & r
    },
    URShift: function (t, e) {
        if (t > Int32.maxValue || t < Int32.minValue) {
            t = Int32.parse(t)
        }
        if (t >= 0) {
            return t >> e
        } else {
            return (t >> e) + (2 << ~e)
        }
    },
    URShiftLong: function (t, e) {
        var r;
        var n = new BigInteger;
        n.fromInt(t);
        if (n.signum() >= 0) {
            r = n.shiftRight(e).intValue()
        } else {
            var i = new BigInteger;
            i.fromInt(2);
            var s = ~e;
            var a = "";
            if (s < 0) {
                var h = 64 + s;
                for (var o = 0; o < h; o++) {
                    a += "0"
                }
                var f = new BigInteger;
                f.fromInt(t >> e);
                var u = new BigInteger("10" + a, 2);
                a = u.toRadix(10);
                var c = u.add(f);
                r = c.toRadix(10)
            } else {
                a = i.shiftLeft(~e).intValue();
                r = (t >> e) + a
            }
        }
        return r
    },
    GetZ: function (t, e) {
        var r = CryptoJS.enc.Utf8.parse("1234567812345678");
        var n = r.words.length * 4 * 8;
        this.Update(n >> 8 & 255);
        this.Update(n & 255);
        var i = this.GetWords(r.toString());
        this.BlockUpdate(i, 0, i.length);
        var s = this.GetWords(t.curve.a.toBigInteger().toRadix(16));
        var a = this.GetWords(t.curve.b.toBigInteger().toRadix(16));
        var h = this.GetWords(t.getX().toBigInteger().toRadix(16));
        var o = this.GetWords(t.getY().toBigInteger().toRadix(16));
        var f = this.GetWords(e.substr(0, 64));
        var u = this.GetWords(e.substr(64, 64));
        this.BlockUpdate(s, 0, s.length);
        this.BlockUpdate(a, 0, a.length);
        this.BlockUpdate(h, 0, h.length);
        this.BlockUpdate(o, 0, o.length);
        this.BlockUpdate(f, 0, f.length);
        this.BlockUpdate(u, 0, u.length);
        var c = new Array(this.GetDigestSize());
        this.DoFinal(c, 0);
        return c
    },
    GetWords: function (t) {
        var e = [];
        var r = t.length;
        for (var n = 0; n < r; n += 2) {
            e[e.length] = parseInt(t.substr(n, 2), 16)
        }
        return e
    },
    GetHex: function (t) {
        var e = [];
        var r = 0;
        for (var n = 0; n < t.length * 2; n += 2) {
            e[n >>> 3] |= parseInt(t[r]) << 24 - n % 8 * 4;
            r++
        }
        var i = new CryptoJS.lib.WordArray.init(e, t.length);
        return i
    }
};
Array.Clear = function (t, e, r) {
    for (elm in t) {
        t[elm] = null
    }
};
Array.Copy = function (t, e, r, n, i) {
    var s = t.slice(e, e + i);
    for (var a = 0; a < s.length; a++) {
        r[n] = s[a];
        n++
    }
};
window.Int32 = {
    minValue: -parseInt("10000000000000000000000000000000", 2),
    maxValue: parseInt("1111111111111111111111111111111", 2),
    parse: function (t) {
        if (t < this.minValue) {
            var e = new Number(-t);
            var r = e.toString(2);
            var n = r.substr(r.length - 31, 31);
            var i = "";
            for (var s = 0; s < n.length; s++) {
                var a = n.substr(s, 1);
                i += a == "0" ? "1" : "0"
            }
            var h = parseInt(i, 2);
            return h + 1
        } else if (t > this.maxValue) {
            var e = Number(t);
            var r = e.toString(2);
            var n = r.substr(r.length - 31, 31);
            var i = "";
            for (var s = 0; s < n.length; s++) {
                var a = n.substr(s, 1);
                i += a == "0" ? "1" : "0"
            }
            var h = parseInt(i, 2);
            return -(h + 1)
        } else {
            return t
        }
    },
    parseByte: function (t) {
        if (t < 0) {
            var e = new Number(-t);
            var r = e.toString(2);
            var n = r.substr(r.length - 8, 8);
            var i = "";
            for (var s = 0; s < n.length; s++) {
                var a = n.substr(s, 1);
                i += a == "0" ? "1" : "0"
            }
            var h = parseInt(i, 2);
            return h + 1
        } else if (t > 255) {
            var e = Number(t);
            var r = e.toString(2);
            return parseInt(r.substr(r.length - 8, 8), 2)
        } else {
            return t
        }
    }
};
(function (t) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = t()
    } else if (typeof define === "function" && define.amd) {
        define([], t)
    } else {
        var e;
        if (typeof window !== "undefined") {
            e = window
        } else if (typeof global !== "undefined") {
            e = global
        } else if (typeof self !== "undefined") {
            e = self
        } else {
            e = this
        }
        e.base64js = t()
    }
})(function () {
    var t, e, r;
    return function s(a, h, o) {
        function f(r, t) {
            if (!h[r]) {
                if (!a[r]) {
                    var e = typeof require == "function" && require;
                    if (!t && e) return e(r, !0);
                    if (u) return u(r, !0);
                    var n = new Error("Cannot find module '" + r + "'");
                    throw n.code = "MODULE_NOT_FOUND", n
                }
                var i = h[r] = {
                    exports: {}
                };
                a[r][0].call(i.exports, function (t) {
                    var e = a[r][1][t];
                    return f(e ? e : t)
                }, i, i.exports, s, a, h, o)
            }
            return h[r].exports
        }
        var u = typeof require == "function" && require;
        for (var t = 0; t < o.length; t++) f(o[t]);
        return f
    }({
        "/": [function (t, e, r) {
            "use strict";
            r.byteLength = a;
            r.toByteArray = h;
            r.fromByteArray = p;
            var f = [];
            var o = [];
            var u = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, s = n.length; i < s; ++i) {
                f[i] = n[i];
                o[n.charCodeAt(i)] = i
            }
            o["-".charCodeAt(0)] = 62;
            o["_".charCodeAt(0)] = 63;

            function c(t) {
                var e = t.length;
                if (e % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4")
                }
                return t[e - 2] === "=" ? 2 : t[e - 1] === "=" ? 1 : 0
            }

            function a(t) {
                return t.length * 3 / 4 - c(t)
            }

            function h(t) {
                var e, r, n, i, s;
                var a = t.length;
                i = c(t);
                s = new u(a * 3 / 4 - i);
                r = i > 0 ? a - 4 : a;
                var h = 0;
                for (e = 0; e < r; e += 4) {
                    n = o[t.charCodeAt(e)] << 18 | o[t.charCodeAt(e + 1)] << 12 | o[t.charCodeAt(e + 2)] << 6 | o[t.charCodeAt(e + 3)];
                    s[h++] = n >> 16 & 255;
                    s[h++] = n >> 8 & 255;
                    s[h++] = n & 255
                }
                if (i === 2) {
                    n = o[t.charCodeAt(e)] << 2 | o[t.charCodeAt(e + 1)] >> 4;
                    s[h++] = n & 255
                } else if (i === 1) {
                    n = o[t.charCodeAt(e)] << 10 | o[t.charCodeAt(e + 1)] << 4 | o[t.charCodeAt(e + 2)] >> 2;
                    s[h++] = n >> 8 & 255;
                    s[h++] = n & 255
                }
                return s
            }

            function l(t) {
                return f[t >> 18 & 63] + f[t >> 12 & 63] + f[t >> 6 & 63] + f[t & 63]
            }

            function v(t, e, r) {
                var n;
                var i = [];
                for (var s = e; s < r; s += 3) {
                    n = (t[s] << 16) + (t[s + 1] << 8) + t[s + 2];
                    i.push(l(n))
                }
                return i.join("")
            }

            function p(t) {
                var e;
                var r = t.length;
                var n = r % 3;
                var i = "";
                var s = [];
                var a = 16383;
                for (var h = 0, o = r - n; h < o; h += a) {
                    s.push(v(t, h, h + a > o ? o : h + a))
                }
                if (n === 1) {
                    e = t[r - 1];
                    i += f[e >> 2];
                    i += f[e << 4 & 63];
                    i += "=="
                } else if (n === 2) {
                    e = (t[r - 2] << 8) + t[r - 1];
                    i += f[e >> 10];
                    i += f[e >> 4 & 63];
                    i += f[e << 2 & 63];
                    i += "="
                }
                s.push(i);
                return s.join("")
            }
        }, {}]
    }, {}, [])("/")
});
(function (t) {
    window.SM4 = t;
    encrypt = 1;
    decrypt = 0;
    round = 32;
    block = 16;
    var e = [214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72];
    var o = [462357, 472066609, 943670861, 1415275113, 1886879365, 2358483617, 2830087869, 3301692121, 3773296373, 4228057617, 404694573, 876298825, 1347903077, 1819507329, 2291111581, 2762715833, 3234320085, 3705924337, 4177462797, 337322537, 808926789, 1280531041, 1752135293, 2223739545, 2695343797, 3166948049, 3638552301, 4110090761, 269950501, 741554753, 1213159005, 1684763257];
    rotl = function (t, e) {
        return t << e | t >>> 32 - e
    };
    byteSub = function (t) {
        return (e[t >>> 24 & 255] & 255) << 24 | (e[t >>> 16 & 255] & 255) << 16 | (e[t >>> 8 & 255] & 255) << 8 | e[t & 255] & 255
    };
    l1 = function (t) {
        return t ^ rotl(t, 2) ^ rotl(t, 10) ^ rotl(t, 18) ^ rotl(t, 24)
    };
    l2 = function (t) {
        return t ^ rotl(t, 13) ^ rotl(t, 23)
    };
    sms4Crypt = function (t, e, r) {
        var n, i, s, a, h, o;
        x = new Array(4);
        tmp = new Array(4);
        for (var f = 0; f < 4; f++) {
            tmp[0] = t[0 + 4 * f] & 255;
            tmp[1] = t[1 + 4 * f] & 255;
            tmp[2] = t[2 + 4 * f] & 255;
            tmp[3] = t[3 + 4 * f] & 255;
            x[f] = tmp[0] << 24 | tmp[1] << 16 | tmp[2] << 8 | tmp[3]
        }
        for (n = 0; n < 32; n += 4) {
            i = x[1] ^ x[2] ^ x[3] ^ r[n + 0];
            i = byteSub(i);
            x[0] = x[0] ^ l1(i);
            i = x[2] ^ x[3] ^ x[0] ^ r[n + 1];
            i = byteSub(i);
            x[1] = x[1] ^ l1(i);
            i = x[3] ^ x[0] ^ x[1] ^ r[n + 2];
            i = byteSub(i);
            x[2] = x[2] ^ l1(i);
            i = x[0] ^ x[1] ^ x[2] ^ r[n + 3];
            i = byteSub(i);
            x[3] = x[3] ^ l1(i)
        }
        for (var u = 0; u < 16; u += 4) {
            e[u] = x[3 - u / 4] >>> 24 & 255;
            e[u + 1] = x[3 - u / 4] >>> 16 & 255;
            e[u + 2] = x[3 - u / 4] >>> 8 & 255;
            e[u + 3] = x[3 - u / 4] & 255
        }
    };
    sms4KeyExt = function (t, e, r) {
        var n, i;
        var s = new Array;
        var a = new Array(4);
        for (var h = 0; h < 4; h++) {
            a[0] = t[0 + 4 * h] & 255;
            a[1] = t[1 + 4 * h] & 255;
            a[2] = t[2 + 4 * h] & 255;
            a[3] = t[3 + 4 * h] & 255;
            s[h] = a[0] << 24 | a[1] << 16 | a[2] << 8 | a[3]
        }
        s[0] ^= 2746333894;
        s[1] ^= 1453994832;
        s[2] ^= 1736282519;
        s[3] ^= 2993693404;
        for (n = 0; n < 32; n += 4) {
            i = s[1] ^ s[2] ^ s[3] ^ o[n + 0];
            i = byteSub(i);
            e[n + 0] = s[0] ^= l2(i);
            i = s[2] ^ s[3] ^ s[0] ^ o[n + 1];
            i = byteSub(i);
            e[n + 1] = s[1] ^= l2(i);
            i = s[3] ^ s[0] ^ s[1] ^ o[n + 2];
            i = byteSub(i);
            e[n + 2] = s[2] ^= l2(i);
            i = s[0] ^ s[1] ^ s[2] ^ o[n + 3];
            i = byteSub(i);
            e[n + 3] = s[3] ^= l2(i)
        }
        if (r === decrypt) {
            for (n = 0; n < 16; n++) {
                i = e[n];
                e[n] = e[31 - n];
                e[31 - n] = i
            }
        }
    };
    t._gencode = _gencode = function (t, e) {
        point = 0;
        inLen = 16;
        var r = new Array(round);
        sms4KeyExt(t.key, r, e);
        var n = new Array(16);
        var i = new Array(16);
        var s = [];
        while (inLen >= block) {
            n = t.source.slice(point, point + 16);
            sms4Crypt(n, i, r);
            s = s.concat(i);
            inLen -= block;
            point += block
        }
        return s
    };

    function s(t) {
        var e = new Array;
        var r, n;
        r = t.length;
        for (var i = 0; i < r; i++) {
            n = t.charCodeAt(i);
            if (n >= 65536 && n <= 1114111) {
                e.push(n >> 18 & 7 | 240);
                e.push(n >> 12 & 63 | 128);
                e.push(n >> 6 & 63 | 128);
                e.push(n & 63 | 128)
            } else if (n >= 2048 && n <= 65535) {
                e.push(n >> 12 & 15 | 224);
                e.push(n >> 6 & 63 | 128);
                e.push(n & 63 | 128)
            } else if (n >= 128 && n <= 2047) {
                e.push(n >> 6 & 31 | 192);
                e.push(n & 63 | 128)
            } else {
                e.push(n & 255)
            }
        }
        return e
    }

    function a(t) {
        var e = 16;
        if (t.length % 16 != 0) e = 16 - t.length % 16;
        var r = new Array(t.length + e);
        for (var n = 0; n < r.length; n++) {
            if (n < t.length) r[n] = t[n];
            else {
                r[n] = e
            }
        }
        return r
    }

    function h(t) {
        if (typeof t === "string") {
            return t
        }
        var e = "",
            r = t;
        for (var n = 0; n < r.length; n++) {
            var i = r[n].toString(2),
                s = i.match(/^1+?(?=0)/);
            if (s && i.length == 8) {
                var a = s[0].length;
                var h = r[n].toString(2).slice(7 - a);
                for (var o = 1; o < a; o++) {
                    h += r[o + n].toString(2).slice(2)
                }
                e += String.fromCharCode(parseInt(h, 2));
                n += a - 1
            } else {
                e += String.fromCharCode(r[n])
            }
        }
        return e
    }
    t.encode = function (t) {
        var e = a(s(t.input));
        var r = Str2Bytes(t.key);
        var n = [];
        for (var i = 0; i < e.length; i += 16) {
            n = n.concat(_gencode({
                source: e.slice(i, i + 16),
                key: r
            }, encrypt))
        }
        return bin2hex(n)
    };
    t.decode = function (t) {
        var e = Str2Bytes(t.input);
        var r = Str2Bytes(t.key);
        var n = [];
        for (var i = 0; i < e.length; i += 16) {
            n = n.concat(_gencode({
                source: e.slice(i, i + 16),
                key: r
            }, decrypt))
        }
        var s = n.length - n[n.length - 1];
        n = n.slice(0, s);
        return h(n)
    }
})({});